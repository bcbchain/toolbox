package gen

import (
	"blockchain/smccheck/parsecode"
	"bytes"
	"go/ast"
	"path/filepath"
	"strings"
	"text/template"
)

var storeTemplate = `package {{.PackageName}}

{{if .Imports}}import ({{end}}
  {{range $v,$vv := .Imports}}
{{$v.Name}} {{$v.Path}}{{end}}
{{if .Imports}}){{end}}

// This file is auto generated by BCB-goland-plugin.
// Don't modified it

{{range $i, $s := .Stores}}
// {{$s|expNames}} {{$s|expType}}
//@:public:store{{$isMap := $s | isM}}{{$isLit := $s | isL}}{{$isBnN := $s | isN}}{{$isStar := $s | isS}}
{{if $isMap}}{{$isMLit := $s|isML}}{{$isMVStar := $s|isMS}}{{if (isNV ($s|expV))}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _{{$s|expNames}}(k {{$s|expK}}) bn.Number {
	temp := bn.N(0)
	return *{{$.ReceiverName}}.sdk.Helper().StateHelper().GetEx(fmt.Sprintf("/{{$s|expNames}}/%v", k), &temp).(*bn.Number)
}{{else}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _{{$s|expNames}}(k {{$s|expK}}) {{$s|expV}} {
	return {{$.ReceiverName}}.sdk.Helper().StateHelper().GetEx(fmt.Sprintf("/{{$s|expNames}}/%v", k), {{if $isMLit}}new({{$s|expVNoS}}){{else}}&{{$s|expVNoS}}{}{{end}}).({{$s|expV}})
}{{end}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _set{{$s|expNames|upperFirst}}(k {{$s|expK}}, v {{$s|expV}}) {
	{{$.ReceiverName}}.sdk.Helper().StateHelper().Set(fmt.Sprintf("/{{$s|expNames}}/%v", k), {{if $isMVStar}}v{{else}}&v{{end}})
}
func ({{$.ReceiverName}} *{{$.ContractName}}) _chk{{$s|expNames|upperFirst}}(k {{$s|expK}}) bool {
	return {{$.ReceiverName}}.sdk.Helper().StateHelper().Check(fmt.Sprintf("/{{$s|expNames}}/%v", k))
}
{{else}}{{if $isBnN}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _{{$s|expNames}}() bn.Number {
	temp := bn.N(0)
	return *{{$.ReceiverName}}.sdk.Helper().StateHelper().GetEx("/{{$s|expNames}}", &temp).(*bn.Number)
}{{else}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _{{$s|expNames}}() {{$s|expType}} {
	return {{if not $isStar}}*{{end}}{{$.ReceiverName}}.sdk.Helper().StateHelper().GetEx("/{{$s|expNames}}",{{if $isLit}}new({{$s|expNoS}}){{else}}&{{$s|expNoS}}{}{{end}}).(*{{$s|expNoS}})
}{{end}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _set{{$s|expNames|upperFirst}}(v {{$s|expType}}) {
	{{$.ReceiverName}}.sdk.Helper().StateHelper().Set("/{{$s|expNames}}", {{if $isStar}}v{{else}}&v{{end}})
}
func ({{$.ReceiverName}} *{{$.ContractName}}) _chk{{$s|expNames|upperFirst}}() bool {
	return {{$.ReceiverName}}.sdk.Helper().StateHelper().Check("/{{$s|expNames}}")
}
{{end}}
{{end}}

{{range $i, $c := .Caches}}
// {{$c|expNames}} {{$c|expType}}
//@:public:store:cache{{$isLit := $c|isL}}{{$isMap := $c|isM}}{{$isBnN := $c | isN}}{{$isStar := $c | isS}}
{{if $isMap}}{{$isMLit := $c|isML}}{{$isMVStar := $c|isMS}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _set{{$c|expNames|upperFirst}}(k {{$c|expK}}, v {{$c|expV}}) {
	{{$.ReceiverName}}.sdk.Helper().StateHelper().McSet(fmt.Sprintf("/{{$c|expNames}}/%v", k), {{if $isMVStar}}v{{else}}&v{{end}})
}{{if (isNV ($c|expV))}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _{{$c|expNames}}(k {{$c|expK}}) bn.Number {
	temp := bn.N(0)
	return *{{$.ReceiverName}}.sdk.Helper().StateHelper().McGetEx(fmt.Sprintf("/{{$c|expNames}}/%v", k), &temp).(*bn.Number)
}{{else}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _{{$c|expNames}}(k {{$c|expK}}) {{$c|expV}} {
	return *{{$.ReceiverName}}.sdk.Helper().StateHelper().McGetEx(fmt.Sprintf("/{{$c|expNames}}/%v", k), new({{$c|expV}})).(*{{$c|expV}})
}{{end}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _clr{{$c|expNames|upperFirst}}(k {{$c|expK}}) {
	{{$.ReceiverName}}.sdk.Helper().StateHelper().McClear(fmt.Sprintf("/{{$c|expNames}}/%v", k))
}
func ({{$.ReceiverName}} *{{$.ContractName}}) _chk{{$c|expNames|upperFirst}}(k {{$c|expK}}) bool {
	return {{$.ReceiverName}}.sdk.Helper().StateHelper().Check(fmt.Sprintf("/{{$c|expNames}}/%v", k))
}
func ({{$.ReceiverName}} *{{$.ContractName}}) _McChk{{$c|expNames|upperFirst}}(k {{$c|expK}}) bool {
	return {{$.ReceiverName}}.sdk.Helper().StateHelper().McCheck(fmt.Sprintf("/{{$c|expNames}}/%v", k))
}
{{else}}{{if $isBnN}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _{{$c|expNames}}() bn.Number {
	temp := bn.N(0)
	return *{{$.ReceiverName}}.sdk.Helper().StateHelper().McGetEx("/{{$c|expNames}}", &temp).(*bn.Number)
} {{else}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _{{$c|expNames}}() {{$c|expType}} {
	return {{if not $isStar}}*{{end}}{{$.ReceiverName}}.sdk.Helper().StateHelper().McGetEx("/{{$c|expNames}}", {{if $isLit}}new ({{$c|expNoS}}){{else}}&{{$c|expNoS}}{}{{end}}).(*{{$c|expNoS}})
}{{end}}
func ({{$.ReceiverName}} *{{$.ContractName}}) _set{{$c|expNames|upperFirst}}(v {{$c|expType}}) {
	{{$.ReceiverName}}.sdk.Helper().StateHelper().McSet("/{{$c|expNames}}", {{if $isStar}}v{{else}}&v{{end}})
}
func ({{$.ReceiverName}} *{{$.ContractName}}) _clr{{$c|expNames|upperFirst}}() {
	{{$.ReceiverName}}.sdk.Helper().StateHelper().McClear("/{{$c|expNames}}")
}
func ({{$.ReceiverName}} *{{$.ContractName}}) _chk{{$c|expNames|upperFirst}}() bool {
	return {{$.ReceiverName}}.sdk.Helper().StateHelper().Check("/{{$c|expNames}}")
}
{{end}}
{{end}}
`

type storeExport struct {
	baseExport
	Imports map[parsecode.Import]struct{}
	Stores  []parsecode.Field
	Caches  []parsecode.Field
}

func res2Store(res *parsecode.Result) storeExport {
	store := storeExport{}
	store.PackageName = res.PackageName
	store.ReceiverName = res.InitChain.Receiver.Names[0]
	store.ContractName = res.ContractStructure
	imports := make(map[parsecode.Import]struct{})
	stores := make([]parsecode.Field, 0)
	caches := make([]parsecode.Field, 0)
	for _, s := range res.Stores {
		stores = append(stores, parsecode.FieldsExpand(s)...)
		for imp := range s.RelatedImport {
			imports[imp] = struct{}{}
		}
		if isMap(s) {
			imports[parsecode.Import{Path: "\"fmt\""}] = struct{}{}
		}
	}
	for _, c := range res.StoreCaches {
		caches = append(caches, parsecode.FieldsExpand(c)...)
		for imp := range c.RelatedImport {
			imports[imp] = struct{}{}
		}
		if isMap(c) {
			imports[parsecode.Import{Path: "\"fmt\""}] = struct{}{}
		}
	}
	store.Stores = stores
	store.Caches = caches
	store.Imports = imports
	return store
}

func GenStore(inPath string, res *parsecode.Result) error {
	filename := filepath.Join(inPath, res.PackageName+"_autogen_store.go")

	funcMap := template.FuncMap{
		"upperFirst": parsecode.UpperFirst,
		"lowerFirst": parsecode.LowerFirst,
		"expNames":   parsecode.ExpandNames,
		"expType":    parsecode.ExpandType,
		"expNoS":     parsecode.ExpandTypeNoStar,
		"expK":       parsecode.ExpandMapFieldKey,
		"expV":       parsecode.ExpandMapFieldVal,
		"expVNoS":    parsecode.ExpandMapFieldValNoStar,
		"isM":        isMap,
		"isS":        isStar,
		"isMS":       isMapFieldValStar,
		"isL":        isLiteralType,
		"isML":       isMapValLiteral,
		"isN":        isBnNumber,
		"isNV":       isBnNumberValue,
	}
	tmpl, err := template.New("store").Funcs(funcMap).Parse(storeTemplate)
	if err != nil {
		return err
	}

	store := res2Store(res)

	var buf bytes.Buffer

	if err = tmpl.Execute(&buf, store); err != nil {
		return err
	}

	if err := parsecode.FmtAndWrite(filename, buf.String()); err != nil {
		return err
	}
	return nil

}

func isMap(f parsecode.Field) bool {
	_, m := f.FieldType.(*ast.MapType)
	return m
}

func isStar(f parsecode.Field) bool {
	_, s := f.FieldType.(*ast.StarExpr)
	return s
}

func isLiteralType(f parsecode.Field) bool {
	id, ok := f.FieldType.(*ast.Ident)
	if !ok {
		id1, ok := f.FieldType.(*ast.SelectorExpr)
		if ok {
			if _, ok = parsecode.LiteralTypes[id1.Sel.Name]; ok {
				return true
			}
		}

		id2, ok := f.FieldType.(*ast.StarExpr)
		if ok {
			if id, ok = id2.X.(*ast.Ident); ok {
				if _, ok = parsecode.LiteralTypes[id.Name]; ok {
					return true
				}
			} else if id1, ok = id2.X.(*ast.SelectorExpr); ok {
				if _, ok = parsecode.LiteralTypes[id1.Sel.Name]; ok {
					return true
				}
			}
		}
		return false
	}
	if _, ok2 := parsecode.LiteralTypes[id.Name]; ok2 {
		return true
	}
	return false
}

func isBnNumber(f parsecode.Field) bool {
	id, ok := f.FieldType.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	if id.Sel.Name == parsecode.NumberType {
		return true
	}
	return false
}

func isBnNumberValue(name string) bool {
	splitName := strings.Split(name, ".")
	if len(splitName) == 2 && splitName[1] == parsecode.NumberType {
		return true
	}

	return false
}

func isMapValLiteral(f parsecode.Field) bool {
	mt, okM := f.FieldType.(*ast.MapType)
	if !okM {
		return false
	}
	id, ok := mt.Value.(*ast.Ident)
	if !ok {
		id1, ok := mt.Value.(*ast.SelectorExpr)
		if ok {
			if _, ok = parsecode.LiteralTypes[id1.Sel.Name]; ok {
				return true
			}
		}

		id2, ok := mt.Value.(*ast.StarExpr)
		if ok {
			if id, ok = id2.X.(*ast.Ident); ok {
				if _, ok = parsecode.LiteralTypes[id.Name]; ok {
					return true
				}
			} else if id1, ok = id2.X.(*ast.SelectorExpr); ok {
				if _, ok = parsecode.LiteralTypes[id1.Sel.Name]; ok {
					return true
				}
			}
		}
		return false
	}
	if _, ok2 := parsecode.LiteralTypes[id.Name]; ok2 {
		return true
	}
	return false

	//if vt, okV := mt.Value.(*ast.Ident); okV {
	//	if _, ok := parsecode.LiteralTypes[vt.Name]; ok {
	//		return true
	//	}
	//} else if st, okS := mt.Value.(*ast.StarExpr); okS {
	//	if id, okI := st.X.(*ast.Ident); okI {
	//		if _, ok := parsecode.LiteralTypes[id.Name]; ok {
	//			return true
	//		}
	//	}
	//}
	//return false
}

func isMapFieldValStar(f parsecode.Field) bool {
	m, ok := f.FieldType.(*ast.MapType)
	if !ok {
		return false
	}
	_, okStar := m.Value.(*ast.StarExpr)
	return okStar
}
